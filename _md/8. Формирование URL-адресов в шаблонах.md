[link](https://proproprogs.ru/django/formirovanie-url-adresov-v-shablonah)
В шаблонах мы используем:
теги `{% имя_тега %}`
переменные `{{ имя_переменной }}`
фильтры `{{ value|имя_фильтра }}`
Теперь сформируем полноценные  ссылки на страницы. Для этого используется специальный тег.
`{% url '<URL-адрес или имя маргрута>' [параметры ссылки] %}`

Вот так будет выглядить маршрут к главной странице в шаблоне base.html
`djsite/coolsite/women/templates/women/base.html`
```HTML
<li class="logo"><a href="/"><div class="logo"></div></a></li>
```
Здесь `href="/"` косая черта указывает на главную страницу. Это не лучший подход, т.к. URL-адрес главной страницы не обязательно должен совпадать с доменным именем. Так же на практике чаще используют имена маршрутов. В файле `women/urls.py` главная страница имеет имя `home`. Воскпользуемся им, указав в теге url:
```HTML
<li class="logo"><a href="{% url 'home' %}"><div class="logo"></div></a></li>
```
## Добавление ссылок для главного меню.
1. Переопределим список menu , указав не только заголовок, но и имя ссылки:
`djsite/coolsite/women/views.py`
```python
menu = [{'title': "О сайте", 'url_name': 'about'},
        {'title': "Добавить статью", 'url_name': 'add_page'},
        {'title': "Обратная связь", 'url_name': 'contact'},
        {'title': "Войти", 'url_name': 'login'},
]
```
2. Сформируем маршруты к этим страницам в `women/urls.py`
```python
urlpatterns = [
    path('', index, name='home'),
    path('about/', about, name='about'),
    path('addpage/', addpage, name='add_page'),
    path('contact/', contact, name='contact'),
    path('login/', login, name='login'),
    path('post/<int:post_id>/', show_post, name='post'),
]
```
3. В файле `women/views.py` пропишем указанные функции представлений:
```python
def index(request):
    posts = Women.objects.all()
    # когда не помещается информация в одну строку создаётся специальный словарь
    context = {
        'posts': posts,
        'menu': menu, 
        'title': "Главная страница"
    }
    return render(request, 'women/index.html', context=context)

def about(request):
    context = {
        'menu':menu, 
        'title': "О сайте"
    }
    return render(request, 'women/about.html', context=context)

def addpage(request):
    return HttpResponse("Добавление статьи")

def contact(request):
    return HttpResponse("Обратная связь")

def login(request):
    return HttpResponse("Войти")

def show_post(request, post_id):
    return HttpResponse(f"Отображение статьи с id = {post_id}")
```
	a. В шаблоне base.html проишем бработчик коллекции menu.
```HTML
{% for m in menu %}
	{% if not forloop.last %}
			<li><a href="{% url m.url_name %}">{{m.title}}</a></li>
	{% else %}
			<li class="last"><a href="{% url m.url_name %}">{{m.title}}</a></li>
	{% endif %}
{% endfor %}
```

## Формирование динамических URL-адресов
Сформируем ссылки у списка наших статей.
![[Pasted image 20220801192227.png]]
1. Для этого в `women/urls.py` есть маршрут
```python
path('post/<int:post_id>/', show_post, name='post'),
```
Чаще всего вместо id используется строка (слаг), записанный латиницей и отражающий суть статьи. Такие ссылки лучше ранжируются поисковыми системами и понятнее пользователям сайта.
2. В файле `women/views.py` прописана функция `show_post`
```python
def show_post(request, post_id):
    return HttpResponse(f"Отображение статьи с id = {post_id}")
```
3. Теперь необходимо определить в шаблоне` index.html` отображение списка статей.
```HTML 
<p class="link-read-post"><a href="{% url 'post' p.pk %}">Читать пост</a></p>
```
Здесь параметр `href` использует уже знакомый тег шаблона url, далее указываем имя ссылки  post и через пробле её параметр post_id в виде p.pk. Параметр pk присутствует в коллекции posts, которая хранит ссылки на объекты класса модели Women. Использует pk, а не id согласно конвенции Django, хотя можно использовать и id
## Сформируем динамитеский URL-адрес через функцию get_absolute_url()
Фреймворк Django работает согласно паттерну MTV(Models, Templates, Views). Т.е. ему постоянно приходится связывать модели с шаблонами и видами, а значит формировать URL-ссылки для выбранных записей из таблицы БД.
В классах моделей можно определять специальный метод под названием `get_absolute_url()` который бы возвращал поный URL-адрес для каждой конкретной записи, ассоциированной с текущим объектом.
`djsite/coolsite/women/models.py`
```python
#from django.db import models
from django.urls import reverse

#class Women(models.Model):
#    title = models.CharField(max_length=255)
#    content = models.TextField(blank=True)
#    photo = models.ImageField(upload_to="photos/%Y/%m/%d")
#    time_create = models.DateTimeField(auto_now_add=True)
#    time_update = models.DateTimeField(auto_now=True)
#    is_published = models.BooleanField(default=True)
#    def __str__(self):
#        return self.title
    def get_absolute_url(self):
        return reverse('post', kwargs={'post_id': self.pk})
```
`djsite/coolsite/women/templates/women/index.html`
```HTML
{% extends 'women/base.html' %}

{% block content %}
<ul class="list-articles">
	{% for p in posts %}
			<li><h2>{{p.title}}</h2>
	{% autoescape on %}
	{{p.content|linebreaks|truncatewords:50}}
	{% endautoescape %}
			<div class="clear"></div>
			<p class="link-read-post"><a href="{{ p.get_absolute_url }}">Читать пост</a></p>
			</li>
	{% endfor %}
</ul>
{% endblock %}

```