# 1. Шаблонизатор  Jinja
Изучение курса [proproprogs.ru](https://proproprogs.ru/modules/chto-eto-ispolzovanie-v-shablonah)
Проект [Jinja](https://jinja.palletsprojects.com/en/2.11.x/
)
Модуль Jinja служит для обработки шаблонов. Основные его плюсы заключаются в простоте использования и богастстве предоставляемых возомжностей для преобразования текстовых шаблонов.
```shell
pip install Jinja2
```
```python
#Jinja/ex1.py
from jinja2 import Template
 
name = "Федор"
 
tm = Template("Привет {{ name }}")
msg = tm.render(name=name)
 
print(msg)
```
Коментарии к примеру выше
1. Созадем обхект Template(шаблонг), которому передаётся строка.
2. Идёт вызов метода render из этого объекта и передаётся именованный параметр name
3. В результате метод render будет ссылаться на словарь с ключом name и значением "Федор"
Данный пример достаточно простой и его можно реализовать при помощь f-строк

Метод `render` класса Tempalte понимает следующие определения:
-   {% %} – спецификатор шаблона;
-   {{ }} – выражение для вставки конструкций Python в шаблон;
-   {# #} – блок комментариев;
-   # ## – строковый комментарий.

```python
name = "Федор"
age = 28
 
tm = Template("Мне {{a*2}} лет и зовут {{ n.upper() }}.")
msg = tm.render(a=age, n=name)
 
print(msg)
```

Пример с использованием класса
```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
per = Person("Jon", 31)
tm = Template("Мне {{p.age}} лет и зовут {{ p.name }}.")
msg = tm.render(p=per)
```

Если в классе реализовать геттры:
```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    def getName(self):
        return self.name
    def getAge(self):
        return self.age
        
per = Person("Jon", 31)
tm = Template("Мне {{p.getAge()}} лет и зовут {{ p.getName() }}.")
msg = tm.render(p=per)

print(msg)
```

Можно обращаться с помощью словаря
```python
per = { 'name': 'Федор', 'age': 34 }
 
tm = Template("Мне {{p.age}} лет и зовут {{ p.name }}.")
# tm = Template("Мне {{p['age']}} лет и зовут {{ p['name'] }}.")
msg = tm.render(p=per)

print(msg)
```

# 2. Экранирование и блоки  raw, for, if
Для экранирования используются специальные определения `{% raw %} … {% endraw %}`
Например:
```python
from jinja2 import Template

data = '''{% raw %}Модуль Jinja вместо
определения {{ name }}
подставляет соответствующее значение{% endraw %}'''

tm = Template(data)
msg = tm.render(name='Федор')

print(msg)
```
## Экранирование символов
При работе с текстовыми HTML-шаблонами иногда есть необходимость экранироввания некоторых символов, котоыре бразузерами воспринимаются как определение тегов:
```python
link = '''В HTML-документе ссылки определяются так: 
<a href="#">Ссылка</a>'''
 
tm = Template("{{ link }}")
msg = tm.render(link = link)
 
print(msg)
```
Чтобы увидеть определение тега  \<a\> вместо самой ссылки то можно прописать флаг `e` - escape (экранирование) `tm = Template("{{link | e}}")`
```python
link = '''В HTML-документе ссылки определяются так: 
<a href="#">Ссылка</a>'''
 
tm = Template("{{link | e}}")
msg = tm.render(link = link)
 
print(msg)
```
В модуле Jinja существует специальный класс escape, который на выходе выдает строку с экранированными символами.
```python
from jinja2 import Template
from markupsafe import escape
 
link = '''В HTML-документе ссылки определяются так: 
<a href="#">Ссылка</a>'''
 
print(escape(link))
```
## Выражение for
```python
{% for <выражение> -%}  
    <повторяемый фрагмент>  
{% endfor %}
```
Данный вид блока позволяет формировать список на основе любого итерируемого объекта, например, упорядоченного списка.
```python
from jinja2 import Template

cities = [{'id': 1, 'city': 'Москва'},
          {'id': 5, 'city': 'Тверь'},
          {'id': 7, 'city': 'Минск'},
          {'id': 8, 'city': 'Смоленск'},
          {'id': 11, 'city': 'Калуга'}]
# минут перед закрывающейся скобкой указывает удалять все переносы и пробелы после блока for и после endfor
link = '''<select name="cities">
{% for c in cities -%}
    <option value="{{c['id']}}">{{c['city']}}</option>
{% endfor -%}
</select>'''

tm = Template(link)
msg = tm.render(cities = cities)

print(msg)
```

## Выражение if
```python
{% if  <условие> %}  
    <фрагмент при истинности условия>  
{% endif %}
```

```python
from jinja2 import Template

cities = [{'id': 1, 'city': 'Москва'},
          {'id': 5, 'city': 'Тверь'},
          {'id': 7, 'city': 'Минск'},
          {'id': 8, 'city': 'Смоленск'},
          {'id': 11, 'city': 'Калуга'}]
          
link = '''<select name="cities">
{% for c in cities -%}
{% if c.id > 6 -%}
    <option value="{{c['id']}}">{{c['city']}}</option>
{%elif c.city == "Москва" -%}
    <option>{{c['city']}}</option>
{%else -%}
    {{c['city']}}
{% endif -%}
{% endfor -%}
</select>'''

tm = Template(link)
msg = tm.render(cities = cities)

print(msg)
```

# 3. Фильтры и макросы: macro, call
Список всех [фильтров](https://jinja.palletsprojects.com/en/2.11.x/templates/#list-of-builtin-filters)
![[Pasted image 20220720160608.png]]
Здесь рассмотрим фильтры, которые удобно применять для получения более сложных представлений.
Синтаксис фильтра sum:
```python
sum(iterable, attribute=None, start=0)
```
```python
from jinja2 import Template

cars = [
    {'model': 'Ауди', 'price': 23000},
    {'model': 'Шкода', 'price': 17300},
    {'model': 'Вольво', 'price': 44300},
    {'model': 'Фольксваген', 'price': 21300}
]

tpl = "Суммарная цена автомобилей {{ cs | sum(attribute='price') }}"
tm = Template(tpl)
msg = tm.render(cs = cars)
 
print(msg)
```
Примеры других фильтров

1. Выводит словарь для автомобиля с максимальной ценой:
	Автомобиль: {'model': 'Вольво', 'price': 44300}
```python
tpl = "Автомобиль: {{ cs | max(attribute='price')  }}"
```
2. Выбор отдельного поля
```python
tpl = "Автомобиль: {{ (cs | max(attribute='price')).model  }}"
```
3. Выбор случайного значения из последовательности
```python
tpl = "Автомобиль: {{ cs | random  }}"
```
4. Замена строчной буквы "о" на заглавную
```python
tpl = 'Автомобиль: {{ cs | replace("о", "О") }}'
```
## Блок filter

```python
{{% filter <название фильтра> %}  
<фрагмент для применения фильтра>  
{% endfilter %}
```

```python
from jinja2 import Template

persons = [
    {"name": "Алексей", "old": 18, "weight": 78.5},
    {"name": "Николай", "old": 28, "weight": 82.3},
    {"name": "Иван", "old": 33, "weight": 94.0}
]
 
tpl = '''
{%- for u in users -%}
{% filter upper %}{{u.name}}{% endfilter %}
{% endfor -%}
'''
 
tm = Template(tpl)
msg = tm.render(users = persons)
 
print(msg)
```
## Макроопределния
В модуле Jinja есть поддержка макроопределений для шаблонов, которые весьма полезны, чтобы измбежать повторяемых определений. DRY - Don't Repeat Yourself
Пример создания нескольких полей ввода input в шаблоне HTML-документа:
```python
from jinja2 import Template
tml = '''
{% macro input(name, value='', type='text', size=20) -%}
    <input type="{{ type }}" name="{{ name }}" value="{{ value|e }}" size="{{ size }}">
{%- endmacro %}
 
{{ input('username') }}
{{ input('email') }}
{{ input('password') }}
'''

tm = Template(tml)
msg = tm.render()

print(msg)
```
Здесь с помощью ключевого слова macro задано макроопределение с именем input и набором параметров. Это очень похоже на определение функций в Python. Учитывая, что в качестве параметров можно указывать специальные:

-   varargs – список переданных значений (параметров);
-   kwargs – список переданных именованных параметров.

А далее, мы используем этот макрос для создания трех полей input.
## Вложенные макросы - call

Определение вложенных макросов
```python
{% call[(параметры)] <вызов макроса> %}  
<вложенный шаблон>  
{% endcall %}
```
Пример формирования вот такого списка:
![[Pasted image 20220721201859.png]]
На уровне HTML список выглядит следующим образом
```html
<ul>
<li>Алексей 
    <ul>
    <li>age: 
    <li>weight: 78.5
    </ul>
<li>Николай 
    <ul>
    <li>age: 
    <li>weight: 82.3
    </ul>
<li>Иван 
    <ul>
    <li>age: 
    <li>weight: 94.0
    </ul>
</ul>
```

```python
from jinja2 import Template


persons = [
    {"name": "Алексей", "old": 18, "weight": 78.5},
    {"name": "Николай", "old": 28, "weight": 82.3},
    {"name": "Иван", "old": 33, "weight": 94.0}
]


html = '''
{% macro list_users(list_of_user) -%}
<ul>
{% for u in list_of_user -%}
    <li>{{u.name}} {{caller(u)}}
{%- endfor %}
</ul>
{%- endmacro %}
 
{% call(user) list_users(users) %}
    <ul>
    <li>age: {{user.old}}
    <li>weight: {{user.weight}}
    </ul>
{% endcall -%}
'''

 
tm = Template(html)
msg = tm.render(users = persons)
 
print(msg)
```
Смотрите, мы здесь прописали call с передаваемым ему параметром user – это будет текущий словарь, взятый из списка persons. Далее, указываем макрос, который следует вызвать для этого блока call. А все что записано внутри этого блока будет подставлено на место вызова метода caller внутри макроса list_users. В результате будет сформирован искомый список.

# 4. Загрузчики: FileSystemLoader, PackageLoader, FunctionLoader и другие
Загрузчики Jinja
-   PackageLoader – для загрузки шаблонов из пакета;
-   DictLoader – для загрузки шаблонов из словаря;
-   FunctionLoader – для загрузки на основе функции;
-   PrefixLoader – загрузчик, использующий словарь для построения подкаталогов;
-   ChoiceLoader – загрузчик, содержащий список других загрузчиков (если один не сработает, выбирается следующий);
-   ModuleLoader – загрузчик для скомпилированных шаблонов.

## FileSystemLoader
Шаблоны, чаще всего, записываются не в виде многострочного текста, а хранятся в отдельных текстовых файлах и загружаются по мере необходимости. Для этого в Jinja реализован класс Enviroment(окружение)
Для этого рядом с файлом .py создадим папку `template` и в ней файл `main.html` с следующим содержимым:
```html
<!DOCTYPE html>
<html>
<head>
		<meta charset="UTF-8">
         <base href="https://proproprogs.ru/">
         <title>Про программирование</title>
</head>
<body>
 
<ul>
{% for u in users -%}
    <li>{{u.name}} 
{% endfor -%}
</ul>
 
</body>
</html>
```
Программа имеет следующий вид:
```python
from jinja2 import Environment, FileSystemLoader
 
persons = [
    {"name": "Алексей", "old": 18, "weight": 78.5},
    {"name": "Николай", "old": 28, "weight": 82.3},
    {"name": "Иван", "old": 33, "weight": 94.0}
]

# Создаем файловый загрузчик, который будет брать шаблоны из подкаталога 'templates'
file_loader = FileSystemLoader('templates')
# Создаётся объект Environment, у которого параметр loader ссылается на файловый загрузчик.
env = Environment(loader=file_loader)


tm = env.get_template('main.html')
msg = tm.render(users = persons)
 
print(msg)
```

Обратите внимание, по умолчанию Python работает со строками в формате Юникода, поэтому для корректного представления кириллицы необходимо сохранять текстовые файлы в формате UTF8.

## FunctionLoader

Для примера реализуем функцию которая будет возвращать шаблон:
```python
def loadTpl(path):
    if path == "index":
        return '''Имя {{u.name}}, возраст {{u.old}}'''
    else:
        return '''Данные: {{u}}'''
```

Полностью код выглядит следующим образом
```python
from jinja2 import Environment, FunctionLoader
 
persons = [
    {"name": "Алексей", "old": 18, "weight": 78.5},
    {"name": "Николай", "old": 28, "weight": 82.3},
    {"name": "Иван", "old": 33, "weight": 94.0}
]

def loadTpl(path):
    if path == "index":
        return '''Имя {{u.name}}, возраст {{u.old}}'''
    else:
        return '''Данные: {{u}}'''

file_loader = FunctionLoader(loadTpl)
env = Environment(loader=file_loader)
 
tm = env.get_template('index')
msg = tm.render(u = persons[0])
 
print(msg)
```

# 5. Конструкции include и import
## Include
Блок для подключения шаблона. Используется для заделения заголовка и подвала на разные файлы.
`{% include <путь к файлу шаблона> %}`
Для этого в папке `template` создаём три файла:
1. header.html
Добавили шаблон для домена и заголовка страницы. 
Вызывая шаблон 'page.html' можно передавать ему домен и заголовок.
```html
<!DOCTYPE html>
<html>
<head>
         <meta charset="UTF-8">
         <base href="{{domain}}">
         <title>{{title}}</title>
</head>
<body>
```
2. footer.html
   ```html
</body>
</html>
```
3. page.html
```html
{% include 'header.html' ignore missing %}
Содержимое страницы
{% include 'footer.html' ignore missing %}
```
содержимое программы
```python
from jinja2 import Environment, FileSystemLoader
 
persons = [
    {"name": "Алексей", "old": 18, "weight": 78.5},
    {"name": "Николай", "old": 28, "weight": 82.3},
    {"name": "Иван", "old": 33, "weight": 94.0}
]
 
file_loader = FileSystemLoader('templates')
env = Environment(loader=file_loader)
 
tm = env.get_template('page.html')
msg = tm.render(domain='http://proproprogs.ru', title="Про Jinja")
 
print(msg)
```
Если в блоке include требуется подключить сразу несколько файлов, то их следует указать в виде списка:
```python
{% include ['page1.htm', 'page2.htm'] ignore missing %}
```

## Конструкция import
Модуль Jinja позволяет не только включать отдельные файлы в общий шаблон, но и импортировать их. При импорте шаблон не добавляется, но можно использовать его отдельные конструкции.
Для примера добавим в HTML-документ диалоговые окна. Их реализацию опишем в виде макроса, который расположим в отдельном файле dialogs.html
```HTML
{% macro dialog_1(title, msg='') -%}
<div class="dialog">
<p class="title">{{title}}</p>
<p class="message">{{msg}}</p>
<input type="button" value="Закрыть"></p>
</div>
{%- endmacro %}
```
импортируем вего в шаблоне page.html
```HTML
{% include 'header.html' ignore missing %}
{% import 'dialogs.html' as dlg %}
Содержимое страницы
{{ dlg.dialog_1('Внимание', 'Это тестовый диалог') }}
{% include 'footer.html' %}
```
