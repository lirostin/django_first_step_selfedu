`coolsite\coolsite\urls.py` В данном файле убираем фрагмент `women`. Теперь за за главную страницу будет отвечать функция представления index
```python
#from women.views import *
#from django.contrib import admin
#from django.urls import path, include
#
#urlpatterns = [
#	path('admin/', admin.site.urls),
	path('', include('women.urls')),
#]
```

### Реализация множеств категорий
Нам необходимо реализовать следующие категории:
127.0.0.1:8000/cats/1/
127.0.0.1:8000/cats/2/

Для этого в файле `coolsite\women\urls.py` вместо `cats` прописать следующий путь `'cats/<int:catid>/'`
```python
#from django.urls import path
#from .views import *
#urlpatterns = [
#	path('', index),
	path('cats/<int:catid>/', categories),
#]
```
Параметр `catid` нужно указать в функции представления `categories`. Для этого в файле `coolsite\women\views.py` пропишем вывод этого параметра.
```python
#from django.http import HttpResponse
#from django.shortcuts import render
#def index(request):
#	return HttpResponse("Страница приложения women.")
#def categories(request, catid):
	return HttpResponse(f"<h1>Статьи по категориям</h1><p>{catid}")
```

Какие ещё можно использовать типы:
-   str – любая не пустая строка, исключая символ ‘/’;
-   int – любое положительное целое число, включая 0;
-   slug – слаг, то есть, латиница ASCII таблицы, символы дефиса и подчеркивания;
-   uuid – цифры, малые латинские символы ASCII, дефис;
-   path – любая не пустая строка, включая символ ‘/’.
-   re_path() например `re_path(r'^archive/(?P<year>[0-9]{4})/', archive),` которая позволяет писать путь `http://127.0.0.1:8000/archive/2020/`
Для теста re_path внесём изменения в файлы:
`coolsite\women\urls.py`
```python
from django.urls import path, re_path
#from .views import *
#urlpatterns = [
#    path('', index),
#    path('cats/<int:catid>/', categories),
    re_path(r'^archive/(?P<year>[0-9]{4})/', archive),
#]
```
`coolsite\women\views.py`
```python
# ...
def archive(request, year):
	return HttpResponse(f"<h1>Архив по годам</h1>{year}</p>")
```

## Обработка GET и POST запросов
Структура ULR-запроса может содержать дополнительные параметры в виде GET-запроса, например `http://127.0.0.1:8000/?name=Gagarina&cat=music`
Чтобы выделить такие значения и обрабатывать их в функциях представления используется ссылка request на объект HttpRequest. Через неё можно обратиться к специальному словарю `request.GET` где и сохраняются эти данные
`coolsite\women\views.py` 
```python
#from django.http import HttpResponse
#from django.shortcuts import render
#def index(request):
#	return HttpResponse("Страница приложения women.")
	if request.GET:
		print(request.GET)
#	return HttpResponse(f"<h1>Статьи по категориям</h1><p>{catid}")
```
POST запросы связаны с передачей данных из форм, пока их не будем рассматривать, просто укажу как их можно использовать
```python
#	return HttpResponse("Страница приложения women.")
	if request.POST:
		print(request.POST)
#	return HttpResponse(f"<h1>Статьи по категориям</h1><p>{catid}")
```

## Обработка исключений при запросах к серверу
Чтобы отключить отображение информации при отладке, необходимо в файле `coolsite\coolsite\settings.py` указать следующие параметры
```python
DEBUG = False #(было True)
ALLOWED_HOSTS = ['127.0.0.1'] #(было [])
```
После этих изменений необходимо **заново зупустить** сервер
### Изменение окна сообщения ошибки, например 404
1. В файле `coolsite\coolsite\urls.py` в пакете конфигурации переопределяем обработчик исключения 404. Для этого присвоим ему ссылку на функцию
   ```python
#from women.views import *
#from django.contrib import admin
#from django.urls import path, include
#urlpatterns = [
#	path('admin/', admin.site.urls),
#	path('', include('women.urls')),
#]

handler404 = pageNotFound
   ```
2. Функцию pageNotFound определяем в приложении women. Функция `pageNotFound` принимает два аргумента и возращает ответ в виде экземпляра класса `HttpResponseNotFound`, которому передаётся HTML-страница, отображаемая при неверных запросах
`coolsite\women\views.py` 
```python
from django.http import HttpResponse, HttpResponseNotFound
#from django.shortcuts import render
#def index(request):
#	return HttpResponse("Страница приложения women.")
#def categories(request, catid):
#	if request.GET:
#		print(request.GET)
#	return HttpResponse(f"<h1>Статьи по категориям</h1><p>{catid}") 
def pageNotFound(request, exception):
	return HttpResponseNotFound('<h1>Страница не найдена</h1>')
```

3. Если какой-либо другой функции представления сгенерировать это исключение, то будет автоматическое перенаправление на функцию pageNotFound. Например, в функции  archive сделаем проверку
`coolsite\women\views.py` 
```python
from django.http import HttpResponse, HttpResponseNotFound, Http404
#from django.shortcuts import render
#
#def index(request):
#    return HttpResponse("Страница приложения women.")
#
#def categories(request, catid):
#    if request.GET:
#        print(request.GET)
#    return HttpResponse(f"<h1>Статьи по категориям</h1><p>{catid}")
#
#def pageNotFound(request, exception):
#    return HttpResponseNotFound('<h1>Страница не найдена</h1>')
#
#def archive(request, year):
    if int(year) > 2022:
        raise Http404()

#    return HttpResponse(f"<h1>Архив по годам</h1>{year}</p>")
```

Аналогичным образом можно переопределять обработчики других исключений:
-   handler500 – ошибка сервера;
-   handler403 – доступ запрещен;
-   handler400 – невозможно обработать запрос.

## Создание 301 и 302 редиректов
-   301 – страница перемещена на другой постоянный URL-адрес;
-   302 – страница перемещена временно на другой URL-адрес.
Делаем перенаправление если год больше 2022, но меньше 3000
`coolsite\women\views.py` 
```python
#from django.http import HttpResponse, HttpResponseNotFound, Http404
from django.shortcuts import render, redirect 

#...

#def archive(request, year):
#    if int(year) > 3000:
#        raise Http404 ()
	"""ниже временое перемещение страницы"""
    elif 2022 < int(year) <= 3000:
        return redirect('/')
    """ниже ПОСТОЯННОЕ перемещение страницы"""
    elif 2022 < int(year) <= 3000:
        return redirect('/', permanent=True)
#    return HttpResponse(f"<h1>Архив по годам</h1>{year}</p>")
```

## Параметр name функции path
Указывать где бы то ни было в приложении конкретный URL-адрес, кроме их списка в коллекции  urlpatterns - это порочная практика или, как ещё говорят - хардкодинг. Вместо этого каждому шаблону пути можно присвоить своё уникальное имя и использовать его в рамках всего проекта.
в `coolsite\women\urls.py` в каждой функции path пропишем параметр  `name` с уникальными именами
```python
#from django.urls import path, re_path
#from .views import *
# 
#urlpatterns = [
    path('', index, name='home'),
    path('cats/<int:catid>/', categories, name='cats'),
    re_path(r'^archive/(?P<year>[0-9]{4})/', archive, name='archive'),
#]
```